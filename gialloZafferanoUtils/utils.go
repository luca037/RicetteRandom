package giallozafferanoutils

import (
	"log"
	"net/http"
	"strings"

	"golang.org/x/net/html"
)

// Rappresenta una ricetta.
type Recipe struct {
	Name, Ingredients, Preparation string
}

// Effettua le richieste agli indirizzi url in urls e insrisce la testa della 
// testa dell'albero html della pagina in heads.
func MkeRequest(urls <-chan string, heads chan<- *html.Node) {
	defer close(heads)
	for url := range urls {
		log.Printf("INFO - Dowload %s\n", url)
		// effettuo richiesta
		resp, err := http.Get(url)
		if err != nil {
			panic("ERROR - Generated by " + url)
		}
		// inserisco testa tree
		head, err := html.Parse(resp.Body)
		if err != nil {
			panic("ERROR - Parsing")
		}
		heads <- head
	}
}

// Effettua il parse degli alberi html delle pagine contenenti gli url delle ricette. 
// Tali alberi sono presenti in heads.
// Inserisce gli url delle ricette in rUrls, in pUrls inserisce il l'url della 
// prossima pagina contenente ricette. Se non sono presenti ulteriori ricette 
// il canale viene chiuso. (Preorder boostrap)
func ParseRecipesPage(heads <-chan *html.Node, rUrls, pUrls chan<- string) {
	defer close(rUrls)
	for head := range heads {
		nextPage := false
		parseRecipesPage(head, rUrls, pUrls, &nextPage)
		if !nextPage {
			close(pUrls)
		}
	}
}

// Preorder traversal.
func parseRecipesPage(node *html.Node, rUrls, urls chan<- string, nextPage *bool) {
	// operazioni su tutti i nodi
	// prelevo il link alla pagina della ricetta
	if node.Parent != nil && node.Type == html.ElementNode {
		if getNodeAttrVal(node.Parent, "class") == "gz-title" {
			rUrls <- getNodeAttrVal(node, "href")
		}
	}
	// prelevo il link alla pagina successiva
	if node.Type == html.ElementNode && node.Data == "a" {
		if getNodeAttrVal(node, "class") == "gz-arrow next" {
			urls <- getNodeAttrVal(node, "href")
			*nextPage = true
		}
	}
	// attraversamento
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		parseRecipesPage(c, rUrls, urls, nextPage)
	}
}

// Ricerca tra gli attributi del nodo e torna il valore corrispondente alla
// key passata.
func getNodeAttrVal(node *html.Node, key string) string {
	for _, a := range node.Attr {
		if key == a.Key {
			return a.Val
		}
	}
	return "noVal"
}

// Effettua il parse degli alberi html corrispondenti alle pagine che contengono 
// nome, ingredienti e preparazione delle ricette. Tali alberi vengono passati
// in heads, le ricette caricate in out. (Preorder boostrap)
func ParseRecipe(heads <-chan *html.Node, out chan<- Recipe) {
	defer close(out)
	for head := range heads {
		var r Recipe
		parseRecipe(head, &r)
		out <- r
	}
}

// Preorder traversal.
func parseRecipe(node *html.Node, rec *Recipe) {
	// titolo ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-title-content gz-innerdesktop" {
		n := strings.TrimSpace(removeNonPrintableASCII(node.Data))
		if len(n) != 0 {
			rec.Name += n
		}
	}
	// ingredienti della ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-ingredient" {
		rec.Ingredients += strings.TrimSpace(removeNonPrintableASCII(node.Data)) + " "
	}
	// preparazione ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-content-recipe-step" {
		prep := strings.TrimSpace(removeNonPrintableASCII(node.Data))
		if len(prep) != 0 {
			rec.Preparation += prep + " "
		}
	}
	// attraversamento albero
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		parseRecipe(c, rec)
	}
}

// Pulizia stringa (vedi ASCII table).
func removeNonPrintableASCII(in string) string {
	var out strings.Builder
	for _, ch := range in {
		if ch >= 32 {
			out.WriteRune(ch)
		}
	}
	return out.String()
}
