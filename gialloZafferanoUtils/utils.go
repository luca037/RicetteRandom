package giallozafferanoutils

import (
	"log"
	"net/http"
	"strings"

	"golang.org/x/net/html"
)

type Recipe struct {
	Name, Ingredients, Preparation string
}

// Effettua le richieste agli indirizzi url passati nel canale e insrisce
// la testa della testa dell'albero html della pagina.
func Request(urls <-chan string, heads chan<- *html.Node) {
	defer close(heads)
	for url := range urls {
		log.Printf("INFO - Dowload %s\n", url)
		// effettuo richiesta
		resp, err := http.Get(url)
		if err != nil {
			panic("ERROR - Generated by " + url)
		}
		// inserisco testa tree
		head, err := html.Parse(resp.Body)
		if err != nil {
			panic("ERROR - Parsing")
		}
		heads <- head
	}
}

// Preorder traversa bootstrap
func ParseRecipesPage(heads <-chan *html.Node, rUrls, pUrls chan<- string) {
	defer close(rUrls)
	for head := range heads {
		nextPage := false
		parseRecipesPage(head, rUrls, pUrls, &nextPage)
		if !nextPage {
			close(pUrls)
		}
	}
}

// Preorder traversal
func parseRecipesPage(node *html.Node, rUrls, urls chan<- string, nextPage *bool) {
	// operazioni su tutti i nodi
	// prelevo il link alla pagina della ricetta
	if node.Parent != nil && node.Type == html.ElementNode {
		if getNodeAttrVal(node.Parent, "class") == "gz-title" {
			rUrls <- getNodeAttrVal(node, "href")
		}
	}
	// prelevo il link alla pagina successiva
	if node.Type == html.ElementNode && node.Data == "a" {
		if getNodeAttrVal(node, "class") == "gz-arrow next" {
			urls <- getNodeAttrVal(node, "href")
			*nextPage = true
		}
	}
	// attraversamento
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		parseRecipesPage(c, rUrls, urls, nextPage)
	}
}

// Ricerca tra gli attributi del nodo e torna il valore corrispondente alla
// key passata.
func getNodeAttrVal(node *html.Node, key string) string {
	for _, a := range node.Attr {
		if key == a.Key {
			return a.Val
		}
	}
	return "noVal"
}

// Preorder traversal bootstrap
func ParseRecipe(heads <-chan *html.Node, out chan<- Recipe) {
    defer close(out)
	for head := range heads {
		var r Recipe
		parseRecipe(head, &r)
		out <- r
	}
}

// Preorder traversal
func parseRecipe(node *html.Node, rec *Recipe) {
	// titolo ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-title-content gz-innerdesktop" {
		title := strings.TrimSpace(removeNonPrintableASCII(node.Data))
		if len(title) != 0 {
			rec.Name += title
		}
	}
	// ingredienti della ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-ingredient" {
		rec.Ingredients += strings.TrimSpace(removeNonPrintableASCII(node.Data)) + " "
	}
	// preparazione ricetta
	if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-content-recipe-step" {
		prep := strings.TrimSpace(removeNonPrintableASCII(node.Data))
		if len(prep) != 0 {
			rec.Preparation += prep + " "
		}
	}
	// attraversamento albero
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		parseRecipe(c, rec)
	}
}

// Pulizia stringa (vedi ASCII table).
func removeNonPrintableASCII(in string) string {
	var out strings.Builder
	for _, ch := range in {
		if ch >= 32 {
			out.WriteRune(ch)
		}
	}
	return out.String()
}
