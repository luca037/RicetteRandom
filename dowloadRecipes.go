package main

import (
	"fmt"
	"net/http"
    "log"
    "strings"
	//"sync"

	"golang.org/x/net/html"
)

const URL = "https://www.giallozafferano.it/ricette-cat/Primi/pasta/"

func main() {
    // salvo i link relativi alle pagine (pagine e ricette) in due channels
    pagesUrls := make(chan string, 50)
    pagesUrls <- URL
    pageHeads := make(chan *html.Node, len(pagesUrls))
    recipesUrls := make(chan string, 15*len(pagesUrls))
    recipesHeads := make(chan *html.Node, len(recipesUrls))

    // run
    go MkeRequest(pagesUrls, pageHeads)
    go ParseRecipesPage(pageHeads, recipesUrls, pagesUrls)
    go MkeRequest(recipesUrls, recipesHeads)

    // stampa
    for head := range recipesHeads {
        parseRecipe(head)
        break
    }
}

// Effettua le richieste agli indirizzi url passati nel canale e insrisce 
// la testa della testa dell'albero html della pagina.
func MkeRequest(urls <-chan string, heads chan<- *html.Node) {
    defer close(heads)
    for url := range urls {
        log.Printf("INFO - Dowload %s\n", url)
        // effettuo richiesta
        resp, err := http.Get(url)
        if err != nil {
            panic("ERROR - Generated by " + url)
        }
        // inserisco testa tree
        head, err := html.Parse(resp.Body)
        if err != nil {
            panic("ERROR - Parsing")
        }
        heads <- head
    }
}

// Preorder traversa bootstrap
func ParseRecipesPage(heads <-chan *html.Node, rUrls, pUrls chan<- string) {
    defer close(rUrls)
    for head := range heads {
        nextPage := false
        parseRecipesPage(head, rUrls, pUrls, &nextPage)
        if !nextPage {
            close(pUrls)
        }
    }
}

// Preorder traversal
func parseRecipesPage(node *html.Node, rUrls, urls chan<- string, nextPage *bool) {
    // operazioni su tutti i nodi
    // prelevo il link alla pagina della ricetta
    if node.Parent != nil && node.Type == html.ElementNode {
        if getNodeAttrVal(node.Parent, "class") == "gz-title" {
            rUrls <- getNodeAttrVal(node, "href")
        }
    }
    // prelevo il link alla pagina successiva
    if node.Type == html.ElementNode && node.Data == "a" {
        if getNodeAttrVal(node, "class") == "gz-arrow next" {
            urls <- getNodeAttrVal(node, "href")
            *nextPage = true
        }
    }
    // attraversamento
    for c := node.FirstChild; c != nil; c = c.NextSibling {
        parseRecipesPage(c, rUrls, urls, nextPage)
    }
}

// Ricerca tra gli attributi del nodo e torna il valore corrispondente alla
// key passata.
func getNodeAttrVal(node *html.Node, key string) string {
    for _, a := range node.Attr {
        if key == a.Key {
            return a.Val
        }
    }
    return "noVal"
}

// Preorder traversal bootstrap
func ParseRecipe(heads <-chan *html.Node) {
    for head := range heads {
        parseRecipe(head)
        break
    }
}

// Preorder traversal
func parseRecipe(node *html.Node) {
    // ingredienti della ricetta
    if node.Type == html.TextNode && getNodeAttrVal(node.Parent.Parent, "class") == "gz-ingredient" {
        for _, ch := range node.Data {
            // pulizia stringa (vedi ASCII table)
            if ch >= 32 && ch <= 126 {
                fmt.Printf("%c", ch)
            }
        }
        fmt.Print(" ")
	}
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		parseRecipe(c)
	}
}
