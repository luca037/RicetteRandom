package main

import (
	"fmt"
	"net/http"
	//"sync"

	"golang.org/x/net/html"
)

const URL = "https://www.giallozafferano.it/ricette-cat/page2/Primi/pasta/"

func main() {
    // salvo i link relativi alle pagine (pagine e ricette) in due channels
    urls := make(chan string, 50)
    links := make(chan string, 15*len(urls))
    htmlHeads := make(chan *html.Node, len(urls))

    urls <- URL
    urls <- URL
    close(urls)

    // run
    go mkeRequest(urls, htmlHeads)
    go parseRecipesPage(htmlHeads, links)

    // stampa
    for link := range links {
        fmt.Println(link)
    }
}

// Effettua le richieste agli indirizzi url passati nel canale e insrisce 
// la testa della testa dell'albero html della pagina.
func mkeRequest(urls <-chan string, hH chan<- *html.Node) {
    defer close(hH)
    for url := range urls {
        fmt.Printf("INFO - Dowload %s\n", url)
        // effettuo richiesta
        resp, err := http.Get(url)
        if err != nil {
            panic("ERROR - Generated by " + url)
        }
        // inserisco testa tree
        head, err := html.Parse(resp.Body)
        if err != nil {
            panic("ERROR - Parsing")
        }
        hH <- head
    }
}

// Preorder traversa bootstrap
func parseRecipesPage(hH <-chan *html.Node, l chan<- string) {
    defer close(l)
    for head := range hH {
        traverseHtmlTree(head, l)
    }
}

// Preorder traversal
func traverseHtmlTree(node *html.Node, l chan<- string) {
    // operazioni su tutti i nodi
    // prelevo il link alla pagina della ricetta
    if node.Parent != nil && node.Type == html.ElementNode {
        for _, ap := range node.Parent.Attr {
            if ap.Key == "class" && ap.Val == "gz-title" {
                l <- getNodeAttrVal(node, "href")
                break
            }
        }
    }

    // prelevo il link alla pagina successiva
    //if node.Type == html.ElementNode && node.Data == "a" {
    //    if getNodeAttrVal(node, "class") == "gz-arrow next" {
    //        //fmt.Println("trovato")
    //        //pl <- getNodeAttrVal(node, "href")
    //        //*nextPage = true
    //    }
    //}

    // attraversamento
    for c := node.FirstChild; c != nil; c = c.NextSibling {
        traverseHtmlTree(c, l)
    }
    // chiusura canali se sono tornato alla testa
     if node.Parent == nil {
    }
}

func getNodeAttrVal(node *html.Node, key string) string {
    for _, a := range node.Attr {
        if key == a.Key {
            return a.Val
        }
    }
    return "noVal"
}
